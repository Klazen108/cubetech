<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!surface_exists(surfA)) surfA = surface_create(608,608); view_surface_id[0] = surfA;
if (!surface_exists(surfB)) surfB = surface_create(608,608); view_surface_id[1] = surfB;
if (!surface_exists(surfC)) surfC = surface_create(608,608); view_surface_id[2] = surfC;
if (!surface_exists(surfD)) surfD = surface_create(608,608); view_surface_id[3] = surfD;
if (!surface_exists(surfE)) surfE = surface_create(608,608); view_surface_id[4] = surfE;
if (!surface_exists(surfF)) surfF = surface_create(608,608); view_surface_id[5] = surfF;

if (objPlayer.x&lt;=608) next_view=cview.A;
else if (objPlayer.x&gt;608 &amp;&amp; objPlayer.x&lt;=1216) {
    if (objPlayer.y&lt;608) next_view=cview.E;
    else if (objPlayer.y&gt;=608 &amp;&amp; objPlayer.y&lt;1216) next_view=cview.B;
    else if (objPlayer.y&gt;=1216) next_view=cview.F;
}
else if (objPlayer.x&gt;1216 &amp;&amp; objPlayer.x&lt;=1824) next_view=cview.C;
else if (objPlayer.x&gt;1824) next_view=cview.D;

if (current_view != next_view) {
    switch (current_view) {
    case cview.A:
        switch (next_view) {
        case cview.B: yrot=-90; break;
        case cview.D: yrot=90; break;
        case cview.E: xrot=90; break;
        case cview.F: xrot=-90; break;
        }
        break;
    case cview.B:
        switch (next_view) {
        case cview.C: yrot=-90; break;
        case cview.A: yrot=90; break;
        case cview.E: zrot=90; break;
        case cview.F: zrot=-90; break;
        }
        break;
    case cview.C:
        switch (next_view) {
        case cview.D: yrot=-90; break;
        case cview.B: yrot=90; break;
        case cview.E: xrot=-90; break;
        case cview.F: xrot=90; break;
        }
        break;
    case cview.D:
        switch (next_view) {
        case cview.A: yrot=-90; break;
        case cview.C: yrot=90; break;
        case cview.E: zrot=-90; break;
        case cview.F: zrot=90; break;
        }
        break;
    case cview.E:
        switch (next_view) {
        case cview.A: xrot=-90; break;
        case cview.C: xrot=90; break;
        case cview.D: zrot=90; break;
        case cview.B: zrot=-90; break;
        }
        break;
    case cview.F:
        switch (next_view) {
        case cview.A: xrot=90; break;
        case cview.C: xrot=-90; break;
        case cview.B: zrot=90; break;
        case cview.D: zrot=-90; break;
        }
        break;
    }
    
    current_view=next_view;
    switching=true;
}

if (switching) {
    if (abs(xrot_current)&lt;abs(xrot)) xrot_current+=2*sign(xrot)
    else xrot_current=xrot;
    if (abs(yrot_current)&lt;abs(yrot)) yrot_current+=2*sign(yrot)
    else yrot_current=yrot;
    if (abs(zrot_current)&lt;abs(zrot)) zrot_current+=2*sign(zrot)
    else zrot_current=zrot;
    
    m_transform=matrix_build(0,0,0,xrot_current,yrot_current,zrot_current,1,1,1);
    m_view_show = matrix_multiply(m_transform,m_view)//matrix_multiply(m_transform,m_view) //set current show view to base view + transform
    if (xrot==xrot_current &amp;&amp; yrot==yrot_current &amp;&amp; zrot==zrot_current) { //if we're done rotating
        switching=false;
        m_view=m_view_show; //save the current show view as the base view
        
        xrot=0; //reset the rotation variables for next time
        yrot=0;
        zrot=0;
        xrot_current=0; //reset the rotation variables for next time
        yrot_current=0;
        zrot_current=0;
    }
}

/*
Gravity: 
A: E+ 90 F- 90
C: E- 90 F+ 90
D: E-180 F+180
E: A- 90 C+ 90 D+180
F: A+ 90 C- 90 D-180
*/
if (hold_player) {
    with (objPlayer) {
        frozen=true;
        x=xprevious;
        y=yprevious;
        vspeed = other.p_vs;
        hspeed = other.p_hs;
    }
    if (!switching) hold_player=false;
} else {
    with (objPlayer) frozen = false;
}
if (switching &amp;&amp; !hold_player) {
    hold_player=true;
    p_vs = objPlayer.vspeed;
    p_hs = objPlayer.hspeed;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>w=304
dist=520; //this seems to work

surfA = surface_create(608,608);
surfB = surface_create(608,608);
surfC = surface_create(608,608);
surfD = surface_create(608,608);
surfE = surface_create(608,608);
surfF = surface_create(608,608);

z_a=0;
thetaY=0;
thetaX=0;

m_view_set=false;
m_view=0;
m_transform=matrix_build(0,0,0,0,0,0,1,1,1);
m_view_show=0;

switching=false;
switch_now=false;
hold_player=false;

enum cview { A,B,C,D,E,F }
if (objPlayer.x&lt;608) current_view=cview.A;
else if (objPlayer.x&gt;=608 &amp;&amp; objPlayer.x&lt;1216) {
    if (objPlayer.y&lt;608) current_view=cview.E;
    else if (objPlayer.y&gt;=608 &amp;&amp; objPlayer.y&lt;1216) current_view=cview.B;
    else if (objPlayer.y&gt;=1216) current_view=cview.F;
}
else if (objPlayer.x&gt;=1216 &amp;&amp; objPlayer.x&lt;1824) current_view=cview.C;
else if (objPlayer.x&gt;=1824) current_view=cview.D;

switch (global.grav) {
    case G_DOWN: m_initial=matrix_build(0,0,0,0,0,0,1,1,1); break;
    case G_UP: m_initial=matrix_build(0,0,0,0,0,180,1,1,1); break;
    case G_LEFT: m_initial=matrix_build(0,0,0,0,0,270,1,1,1); break;
    case G_RIGHT: m_initial=matrix_build(0,0,0,0,0,90,1,1,1); break;
}
switch (current_view) {
    case cview.A:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,0,0,1,1,1),m_initial);
        show_debug_message("intial: A");
        break;
    case cview.B:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,-90,0,1,1,1),m_initial);
        show_debug_message("intial: B");
        break;
    case cview.C:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,-180,0,1,1,1),m_initial);
        show_debug_message("intial: C");
        break;
    case cview.D:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,-270,0,1,1,1),m_initial);
        show_debug_message("intial: D");
        break;
    case cview.E:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,-90,0,1,1,1),m_initial);
        m_initial=matrix_multiply(matrix_build(0,0,0,0,0,90,1,1,1),m_initial);
        show_debug_message("intial: E");
        break;
    case cview.F:
        m_initial=matrix_multiply(matrix_build(0,0,0,0,-90,0,1,1,1),m_initial);
        m_initial=matrix_multiply(matrix_build(0,0,0,0,0,-90,1,1,1),m_initial);
        show_debug_message("intial: F");
        break;
}

xrot=0;
yrot=0;
zrot=0;
xrot_current=0;
yrot_current=0;
zrot_current=0;

view_visible[0]=true;
view_visible[1]=true;
view_visible[2]=true;
view_visible[3]=true;
view_visible[4]=true;
view_visible[5]=true;
view_visible[6]=false; //debug view
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_black);
draw_set_alpha(1);
draw_rectangle(0,0,800,608,0);

d3d_start(); 
//d3d_set_lighting(true); 
//d3d_light_define_direction(1,1,0.5,0,c_white);
//d3d_light_enable(1,true);

d3d_set_culling(true); 
d3d_set_perspective(true);
d3d_set_projection_ext(0, 0, -dist, 0, 0, 0, 0, 1, 0,45,400/304,1,6000);

draw_set_color(c_white);
d3d_transform_set_identity();
//d3d_transform_add_rotation_y(thetaY);
//d3d_transform_add_rotation_x(thetaX);

if (!m_view_set) {
    m_view=matrix_get(matrix_world);
    m_view = matrix_multiply(m_initial,m_view);
    
    m_view_show=m_view;
    m_view_set=true;
}
matrix_set(matrix_world,m_view_show);

//d3d_draw_block(-d,-d,-d,+d,+d,d,-1,1,1);

var d=w/2;

//assume:
//x = - left, + right
//y = - down, + up
//z = - out, + in

//A
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfA));
d3d_vertex_texture(-d,+d,-d,0,0);
d3d_vertex_texture(+d,+d,-d,1,0);
d3d_vertex_texture(+d,-d,-d,1,1);
d3d_vertex_texture(-d,-d,-d,0,1);
d3d_primitive_end();

//B
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfB));
d3d_vertex_texture(+d,+d,-d,0,0);
d3d_vertex_texture(+d,+d,+d,1,0);
d3d_vertex_texture(+d,-d,+d,1,1);
d3d_vertex_texture(+d,-d,-d,0,1);
d3d_primitive_end();

//C
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfC));
d3d_vertex_texture(+d,+d,+d,0,0);
d3d_vertex_texture(-d,+d,+d,1,0);
d3d_vertex_texture(-d,-d,+d,1,1);
d3d_vertex_texture(+d,-d,+d,0,1);
d3d_primitive_end();

//D
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfD));
d3d_vertex_texture(-d,+d,+d,0,0);
d3d_vertex_texture(-d,+d,-d,1,0);
d3d_vertex_texture(-d,-d,-d,1,1);
d3d_vertex_texture(-d,-d,+d,0,1);
d3d_primitive_end();

//E
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfE));
d3d_vertex_texture(-d,+d,-d,0,0);
d3d_vertex_texture(-d,+d,+d,1,0);
d3d_vertex_texture(+d,+d,+d,1,1);
d3d_vertex_texture(+d,+d,-d,0,1);
d3d_primitive_end();

//F
d3d_primitive_begin_texture(pr_trianglefan,surface_get_texture(surfF));
d3d_vertex_texture(+d,-d,-d,0,0);
d3d_vertex_texture(+d,-d,+d,1,0);
d3d_vertex_texture(-d,-d,+d,1,1);
d3d_vertex_texture(-d,-d,-d,0,1);
d3d_primitive_end();

d3d_set_culling(false); 
d3d_set_perspective(false);
d3d_set_projection_ortho(0,0,800,608,0);
d3d_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
